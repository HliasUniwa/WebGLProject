<!DOCTYPE HTML>
<html>
<head>
<meta charset="UTF-8">
<script src="webgl-debug.js"></script>
<script src="gl-matrix-min.js"></script>

<script id="vShader" type="x-shader/x-vertex">
attribute vec4 aVertexPosition;
attribute vec4 aVertexColor;
uniform mat4 uVerticesTransform;
//PINAKAS METASXIMATISMOU KAMERAS
uniform mat4 uPerspectiveViewTransform;

varying vec4 vColor;
void main() {
    gl_Position = uPerspectiveViewTransform * uVerticesTransform * aVertexPosition;
    vColor = aVertexColor;
}
</script>

<script id="fShader" type="x-shader/x-fragment">
precision mediump float;
varying vec4 vColor;
void main() {
    gl_FragColor = vColor;
}
</script>

<script>

var gl;
var canvas;
var shadersProgram;
var vertexPositionAttributePointer;
var vertexColorAttributePointer;
var verticesTransformUniformPointer;
var vertexBuffer;
//POINTER CAMERAS
var perspectiveViewUniformPointer;

//ΠΡΟΣΘΕΣΤΕ ΕΔΩ ΤΗ ΔΗΛΩΣΗ ΜΙΑΣ GLOBAL ΜΕΤΑΒΛΗΤΗΣ totalZ ΓΙΑ ΤΟ ΣΥΝΟΛΙΚΟ ΥΨΟΣ Z ΤΗΣ ΚΑΜΕΡΑΣ ΚΑΙ ΑΡΧΙΚΟΠΟΙΗΣΤΕ ΤΗ ΣΕ 2
var totalZ = 2;
//GWNIA THEASIS
var ViewAngle=90*Math.PI/180;
var colorBuffer;
var indexBuffer;
var totalAngle = -1;
var requestID = 0; // ΝΕΟΤΕΡΟ.0

// pinakas prooptikis , topothetisis , ginomeno kai twn 2
var arrX = new Float32Array(16);
var arrY = new Float32Array(16);
var arrZ = new Float32Array(16);

function createGLContext(inCanvas) {
var outContext = null;
outContext = inCanvas.getContext("webgl");
if (!outContext)
outContext = inCanvas.getContext("experimental-webgl");
if (!outContext)
alert("WebGL rendering context creation error.");

return outContext;
}

function createCompileShader(shaderType, shaderSource) {
    var outShader = gl.createShader(shaderType);
    gl.shaderSource(outShader, shaderSource);
    gl.compileShader(outShader);
    if (!gl.getShaderParameter(outShader, gl.COMPILE_STATUS)) {
        alert( "Shader compilation error. " + gl.getShaderInfoLog(outShader) );
        gl.deleteShader(outShader);
    outShader = null;
    }
    return outShader;
}

function initShaders() {
    var vertexShaderSource = document.getElementById("vShader").textContent;
    var fragmentShaderSource = document.getElementById("fShader").textContent;
    var vertexShader = createCompileShader(gl.VERTEX_SHADER, vertexShaderSource);
    var fragmentShader = createCompileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
    shadersProgram = gl.createProgram();
    gl.attachShader(shadersProgram, vertexShader);
    gl.attachShader(shadersProgram, fragmentShader);
    gl.linkProgram(shadersProgram);
    if (!gl.getProgramParameter(shadersProgram, gl.LINK_STATUS)) {
        alert("Shaders linking error.");
    }
    gl.useProgram(shadersProgram);
    vertexPositionAttributePointer = gl.getAttribLocation(shadersProgram, "aVertexPosition");
    gl.enableVertexAttribArray(vertexPositionAttributePointer);
    vertexColorAttributePointer = gl.getAttribLocation(shadersProgram, "aVertexColor");
    gl.enableVertexAttribArray(vertexColorAttributePointer);
    verticesTransformUniformPointer = gl.getUniformLocation(shadersProgram, "uVerticesTransform");

    // ΒΗΜΑ 0.5 Αποθηκεύστε στο σχετικό pointer (η global μεταβλητή) τη διεύθυνση του νέου uniform uPerspectiveViewTransform 
    // (όπως η ακριβώς γίνεται στην προηγούμενη εντολή για το άλλο uniform με τον άλλο pointer
    perspectiveViewUniformPointer = gl.getUniformLocation(shadersProgram, "uPerspectiveViewTransform"); 
}

function initBuffers() {
    var triangleVertices = new Float32Array([
        // Top
        -1.0, 1.0, -1.0,   
		-1.0, 1.0, 1.0,    
		1.0, 1.0, 1.0,     
		1.0, 1.0, -1.0,    

		// Left
		-1.0, 1.0, 1.0,    
		-1.0, -1.0, 1.0,   
		-1.0, -1.0, -1.0,  
		-1.0, 1.0, -1.0,   

		// Right
		1.0, 1.0, 1.0,    
		1.0, -1.0, 1.0,   
		1.0, -1.0, -1.0,  
		1.0, 1.0, -1.0,   

		// Front
		1.0, 1.0, 1.0,    
		1.0, -1.0, 1.0,    
		-1.0, -1.0, 1.0,    
		-1.0, 1.0, 1.0,    

		// Back
		1.0, 1.0, -1.0,    
		1.0, -1.0, -1.0,    
		-1.0, -1.0, -1.0,    
		-1.0, 1.0, -1.0,    

		// Bottom
		-1.0, -1.0, -1.0,   
		-1.0, -1.0, 1.0,    
		1.0, -1.0, 1.0,     
		1.0, -1.0, -1.0,    

    ]);
    vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);
    vertexBuffer.itemSize = 3;
    vertexBuffer.itemCount = 24;

    var triangleColors = new Float32Array([
		0.0, 0.0, 1.0, //A
	    0.0, 0.0, 0.9, //B
	    0.0, 0.0, 0.8, //C
	    0.0, 0.0, 0.7, //D

		0.0, 0.0, 0.6, //E
        0.0, 0.0, 0.5, //F
        0.0, 0.0, 0.4, //G
		0.0, 0.0, 0.3, //H

		0.0, 0.0, 0.7,//D
        0.0, 0.0, 0.8,//C
        0.0, 0.0, 0.4,//G
        0.0, 0.0, 0.3,//H

		0.0, 0.0, 1.0,//A
	    0.0, 0.0, 0.9,//B
        0.0, 0.0, 0.5,//F
	    0.0, 0.0, 0.1,//E

		0.0, 0.0, 0.9,//B
	    0.0, 0.0, 0.8,//C
	    0.0, 0.0, 0.4,//G
        0.0, 0.0, 0.5,//F

		0.0, 0.0, 1.0,//A
	    0.0, 0.0, 0.6,//D
	    0.0, 0.0, 0.3,//H
	    0.0, 0.0, 0.6,//E
    ]);
    colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, triangleColors, gl.STATIC_DRAW);
    colorBuffer.itemSize = 3;
    colorBuffer.itemCount = 24;

    var indexMatrix = new Uint16Array([
        0, 1, 2,  // Front face
        0, 2, 3,  // Front face

        5, 4, 6,  // Back face
        6, 4, 7,  // Back face

        8, 9, 10,  // Top face
        8, 10, 11,  // Top face

        12, 13, 14,  // Bottom face
        15, 14, 12,  // Bottom face

        16, 17, 18,  // Right face
        16, 18, 19,  // Right face

        21, 20, 22,  // Left face
        22, 20, 23,  // Left face
    ]);
    indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexMatrix, gl.STATIC_DRAW);
    indexBuffer.itemCount = 36;
}

function drawScene() {
//DHMIOURGIA KAMERAS KAMERAS KAMERAS
    //  ΒΗΜΑ 0.6 Αρχικοποιείται σε μοναδιαίο πίνακα o pvMatrix για να "ταϊστεί" στοιχειωδώς το νέο uniform (χρησιμοποιήστε την identity της βιβλιοθήκης)
	var pvMatrix = new Float32Array(16);
	glMatrix.mat4.identity(pvMatrix);
    //ΝΑ ΔΗΜΙΟΥΡΓΗΘΕΙ Ο ΠΙΝΑΚΑΣ viewMatrix (View Matrix) me thesi kameras [7,7,7] και προσανατολισμό προς τα επάνω ομόρροπο με τον άξονα z
    var x = 5*Math.cos(totalAngle);
	var y = 5*Math.sin(totalAngle);
	var vMatrix = new Float32Array(16);
	glMatrix.mat4.lookAt(vMatrix,[x,y,totalZ],[0,0,0],[0,0,1]);

    //ΝΑ ΔΗΜΙΟΥΡΓΗΘΕΙ Ο ΠΙΝΑΚΑΣ perspectiveMatrix (Perspective Matrix) ΚΑΙ ΝΑ ΠΕΡΙΕΧΕΙ ΤΟ ΜΕΤΑΣΧΗΜΑΤΙΣΜΟ ΓΙΑ ΤΗΝ ΠΡΟΟΠΤΙΚΗ
    var pMatrix = new Float32Array(16);
	glMatrix.mat4.perspective(pMatrix, ViewAngle, 1, 0.001, 100);

    //dhmiourgia pinaka pvMatrix(ginomeno pinakwn)
    glMatrix.mat4.multiply(pvMatrix,pMatrix,vMatrix);

    //Ταΐζεται ο (προς το παρόν μοναδιαίος) πίνακας κάμερας/προοπτικής στο νέο uniform
    gl.uniformMatrix4fv(perspectiveViewUniformPointer, false, pvMatrix);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

//TELOS KAMERAS KAMERAS KAMERAS!!!!!!


    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(vertexPositionAttributePointer, vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(vertexColorAttributePointer, colorBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //ΒΗΜΑ ΠΕΡΙΣΤΡΟΦΗΣ
    var txtStepAngle; 
	txtStepAngle = document.getElementById("stepAngleTxt").value; 
	var numStepAngle = parseFloat(txtStepAngle);
	numStepAngle = numStepAngle*Math.PI/180.0; 
	totalAngle += numStepAngle;

    //ΥΨΟΣ ΚΑΜΕΡΑΣ
    var txtZ; 
	txtZ = document.getElementById("txtZ").value; 
	var numZ = parseFloat(txtZ);
	totalZ = numZ;

    //ΓΩΝΙΑ ΘΕΑΣΗΣ
    var txtVa;
    txtVa = document.getElementById("txtVa").value;
    var numVa = parseInt(txtVa);
    numVa = numVa * Math.PI/180;
    ViewAngle = numVa;


    var translationMatrix = new Float32Array(16);
    
	glMatrix.mat4.fromTranslation(translationMatrix,[0,0,0]);
	gl.uniformMatrix4fv(verticesTransformUniformPointer, false, translationMatrix); 
	gl.drawElements(gl.TRIANGLES,indexBuffer.itemCount,gl.UNSIGNED_SHORT, 0);

}

function main() {
    minDimension = Math.min(window.innerHeight, window.innerWidth);
    canvas = document.getElementById("sceneCanvas");
    canvas.width = 0.9*minDimension;
    canvas.height = 0.9*minDimension;
    gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
    initShaders();
    initBuffers();
    gl.clearColor(0.5, 0.5, 0.5, 1.0);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.enable(gl.DEPTH_TEST);
    drawScene();
}

// ΝΕΟΤΕΡΟ.1
function startAnimation() {
    if (requestID == 0)
    requestID = window.requestAnimationFrame(animationStep);
}

// ΝΕΟΤΕΡΟ.2
function animationStep() {
    drawScene();
    requestID = window.requestAnimationFrame(animationStep);
}

// ΝΕΟΤΕΡΟ.3
function stopAnimation() {
    window.cancelAnimationFrame(requestID);
    requestID = 0;
}

</script>

</head>

<body onload="main()">
<canvas id="sceneCanvas">
</canvas>
<p>
Βήμα γωνίας περιστροφής:<input type="text" id="stepAngleTxt" value="0.5" autocomplete="off"><br>
Γωνία θέασης:<input type="text" id="txtVa" value="90" autocomplete="off">
Βήμα ύψους:<input type="text" id="txtZ" value="2" autocomplete="off"> 


<button id="startButton" onclick="startAnimation()">Ξεκίνα!</button>
<button id="stopButton" onclick="stopAnimation()">Σταμάτα!</button>
</p>
</body>
</html>

<!--
Βήμα.-1. (read-only) Παρατηρήστε ότι (για λόγους που θα φανούν στη συνέχεια) η περιστροφή αυτή τη φορά είναι γύρω από τον άξονα x.
Δημιουργήθηκε στην εντολή ΒΗΜΑ.-1 πίνακας περιστροφής γύρω από τον άξονα x'x.

ANIMATION
Βήμα.0. (read-only) Παρατηρήστε το μηχανισμό του animation. Το κουμπί start καλεί τη startAnimation (ΝΕΟΤΕΡΟ.1).
Αυτή, αν το requestId είναι null (το requestId είναι global μεταβλητή - ΝΕΟΤΕΡΟ.0), καλεί την animationStep() (ΝΕΟΤΕΡΟ.2). Αν το requestId έχει τιμή διαφορετική από 0 δεν καλείται η animationStep() - αυτό γίνεται για να υπάρχει μόνο μία μοναδική ακολουθία requests).

Η animationStep αρχικά καλεί τη drawScene που σχεδιάζει μια νέα εκδοχή της σκηνής. Στη συνέχεια, υποβάλλει αίτημα για animation frame, λαμβάνει requestId και εντάσσεται σε ουρά (callback list) μία επόμενη κλήση της. Όταν έρχεται η ώρα εκτέλεσης της κλήσης που είναι στην ουρά, εκτελείται η drawScene και μία νέα κλήση μπαίνει στην ουρά κ.ο.κ.

Το animation σταματά μέσω της stopAnimation (ΝΕΟΤΕΡΟ.3) με αίτημα ακύρωσης της επανεκτέλεσης της animationStep, μέσω του (τελευταίου) requestId που είχε λάβει, και το requestId τίθεται 0 ώστε να μπορεί να ξαναρχίσει.

ΔΙΑΛΟΓΗ ΟΨΕΩΝ
Βήμα.1. Εκτελέστε τον κώδικα ως έχει και μετά αφαιρέστε τα σχόλια στις ΝΕΟΤΕΡΟ.4, ΝΕΟΤΕΡΟ.5, ΝΕΟΤΕΡΟ.6 ώστε να ενεργοποιηθούν οι
εντολές στο τέλος της main.
Τι παρατηρείτε;
Συμβουλευτείτε τις σχετικές διαφάνειες του εργαστηρίου και διορθώστε τις συντεταγμένες του τριγώνου ώστε ΑΡΧΙΚΑ αυτό να είναι ορατό.

TRIANGLE STRIP & ΔΙΑΛΟΓΗ ΟΨΕΩΝ
Bήμα.2. (read-only) Η πρώτη παράμετρος της gl.drawArrays είναι gl.TRIANGLE_STRIP.
Δείτε στις σχετικές διαφάνειες του εργαστηρίου με ποιο τρόπο λαμβάνεται υπόψη η σειρά των κορυφών, των οποίων τις συντεταγμένες έχουμε δώσει μέσα στον πίνακα στην initBuffers, όταν αυτές είναι περισσότερες από 3.

Βήμα.3. Λαμβάνοντας υπόψη και το Βήμα.2. μετατρέψτε το τρίγωνο σε τετράγωνο που οι 4 κορυφές του βρίσκονται στα x=+/- 0.5, y=+/- 0.5, z=0.
Φροντίστε να είναι ΑΡΧΙΚΑ να είναι ορατό (δηλαδή να μην το απορρίπτει η ΔΙΑΛΟΓΗ ΟΨΕΩΝ), παρόμοια με το Βήμα.1. Οι αλλαγές που χρειάζονται να γίνουν είναι όλες στην initBuffers.

Βήμα.4. Προσπαθήστε να επεκτείνετε το τετράγωνο του προηγούμενου βήματος στο TAY του σχήματος στην τελευταία σχετική διαφάνεια του εργαστηρίου, χρησιμοποιώντας TRIANGLE_STRIP και διαλογή όψεων.

-->